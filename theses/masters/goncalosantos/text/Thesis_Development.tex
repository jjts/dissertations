%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                     %
%     File: Thesis_Development.tex                                    %
%     Tex Master: Thesis.tex                                          %
%                                                                     %
%     Author: GonÃ§alo Santos                                          %
%     Last modified : 28 May 2019                                     %
%                                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Development}
\label{chapter:develop}

The {\bf lcc} compiler (see section~\cite{Fraser:1991b,lcc4}) is a
retargetable compiler with a single {\it front-end} for the {\bf C}
programming language ({\sc ANSI-C}).
As a retargetable compiler, multiple {\it back-ends} are available
and new ones can be easily added.
Currently, {\bf lcc} produces {\bf mips}, {\bf sparc} and
{\bf intel-x86} assembly, amongst other output formats.
Most formats, including the three referred, use an instruction
selector (see section~\ref{burg}) to generate and optimize the
output assembly code.
The {\bf lcc} compiler uses a specific instruction selection
tool ({\bf lburg}), included in the compiler distribution.
Ideally, the creation of a new {\it back-end} corresponds to an
{\bf lburg} grammar description, some auxiliary functions,
and a controlling structure.
A reference to the controlling structure is then inserted
into the {\tt src/bind.c} file and the {\bf makefile} update.

The {\bf lburg} grammar description file is composed of three
areas separated by a single line containing only the sequence
{\tt \%\%}, like other grammar description files for lexical
analysis (see section~\ref{lex}) or syntactic analysis
(see section~\ref{yacc}).
The first area contains declarations, the second area
contains the grammar, and the last area may contain
{\bf C} language functions and variables.
The declarations area includes a {\tt \%start} declaration,
{\tt \%term} declarations, and {\bf C} language declarations.
The {\tt \%start} declaration identifies the grammar
non-terminal that each {\sc AST} tree must produce,
based on the grammar tree patterns. If the start
non-terminal can not be produced from any combination
of the grammar rules, then an error is generated and
no output is produced. The {\it Versat} grammar uses
{\tt stmt}, or statement, as the start symbol for the grammar.
The {\tt \%term} declaration associates a symbolic name used
in the patterns of each rule with the number stored in the
terminal nodes of the tree ({\sc AST}) which represents
the program.
For instance, a tree node containing an integer of metric $1$,
usually a {\bf C} language {\tt char} type, is labeled with
the $1045$ value by the {\bf lcc} compiler, and associated
with the name {\tt CNSTI1} by the {\it Versat} {\it back-end}
with the declaration {\tt \%term CNSTI1=1045}.

The values that correspond to each terminal type in the
tree can be computed based on the operation, the data
type and the metric.
The operation is one of $35$ types of instructions
generated by the compiler for all {\bf C} language constructs.
The instruction are numbered from $1$ ({\tt CNST}) to $37$
({\tt LABEL}) and $44$ ({\tt VREG}).
The full list (see~\cite[p.84]{hanson95} include
{\tt CNST} (a literal constant),
{\tt ARG} (a function argument),
{\tt ASGN} (an assignment),
{\tt INDIR} (a pointer dereferencing),
{\tt CVF} (a conversion from floating point),
{\tt CVI} (a conversion from an integer),
{\tt CVU} (a conversion from an unsigned integer),
{\tt CVP} (a conversion from a pointer),
{\tt NEG} (the symmetric value),
{\tt CALL} (a function call),
{\tt LOAD} (a register movement),
{\tt RET} (the return from a function),
{\tt ADDRG} (address of a global variable),
{\tt ADDRF} (address of a function argument),
{\tt ADDRL} (address of a local variable),
{\tt ADD} (arithmetic sum),
{\tt SUB} (arithmetic subtraction),
{\tt LSH} (a left shift),
{\tt MOD} (division integer remainder),
{\tt RSH} (a right shift),
{\tt BAND} (a bit-wise and),
{\tt BCOM} (a bit-wise complement),
{\tt BOR} (a bit-wise inclusive or),
{\tt BXOR} (a bit-wise exclusive-or),
{\tt DIV} (arithmetic division),
{\tt MUL} (arithmetic multiplication),
{\tt EQ} (an equal comparison),
{\tt GE} (a greater or equal comparison),
{\tt GT} (a greater than comparison),
{\tt LE} (a less or equal comparison),
{\tt LT} (a less than comparison),
{\tt NE} (a not equal comparison),
{\tt JUMP} (an unconditional jump),
{\tt LABEL} (a global label),
{\tt VREG} (a register variable).
The data type can be {\tt F} (floating point),
{\tt I} (signed integer), {\tt U} (unsigned integer),
{\tt P} (any pointer type), {\tt V} (void) and
{\tt B} (structure type).
The metric is the size of the variable,
where {\tt sizeof(char)} must be $1$
(see~\cite[p.79]{hanson95})
as is required by the {\bf C} programming language.
However, not all instructions can be applied for all
data types, and are only available for some metric values.
For instance, {\tt ADDRG} only supports {\tt P} for
the processor word size, {\em i.e.} {\tt ADDRP4} for
a 32-bit machine and {\tt ADDRP8} for a 64-bit machine.
On the other hand, addition is supported for almost
all data types, except void and structure,
and all metrics.

The {\it Versat} {\it back-end} defines only metric
$1$ terminals since a character has metric $1$,
although it occupies 32-bits, as all other
integer data types.

\section{{\bf lcc} compiler interface}
% [asdl.pdf:6-7]
As referred, the {\it back-end} is registered in the
compiler by a single data structure,
{\tt Interface versatIR} in this case.
This structure defines the processor metrics.
In {\it Versat} all data types have a size
metric of $1$ except the {\bf long long},
{\bf double} and {\bf long double} that
should occupy $2$ words, although they
are currently not implemented.
All data types are word aligned, so the align
metric is always $1$.
These metrics correctly map address computations
but fail to address literals, since {\bf lcc}
assumes that a type {\tt char} is 8-bits and
its size is $1$ ({\tt sizeof(char)==1}).
Although this is true for most common computers
of today, old computers and specific processors
had different size words.
Processors, like {\it Versat}, that are not
used for general computing, do not have
different size data types.
Instead, all data types are 32-bits long,
which is a wast of space for character processing.

In order to circumvent the {\bf lcc} assumption
that characters are always 8-bits long, the
data types minimum and maximum values were
hacked for the {\it Versat} {\it back-end} in
the file {\tt types.c}:
\begin{Verbatim}[baselinestretch=1.2]
    types.c:42
        int i; for (i = 0; bindings[i].ir != IR; i++);
        int versat = !strcmp(bindings[i].name, "versat");
    types.c:51
        if (versat) p->u.limits.max.i = ones(32)>>1;
    types.c:56
        if (versat) p->u.limits.max.u = ones(32);
\end{Verbatim}

However, pointer literals are not computed from
data types but from metric sizes, assuming
8-bits per byte.
Since the code ({\tt 8}$^{\wedge}${\tt ty->size})
is spread out all over the compiler, a major
rewriting was needed.
Instead, pointer literals should be assigned to
integers and then converted into pointers, as
referred in the section~\ref{limitations}.
This is not a common {\bf C} operation, specially
in virtual memory machines, but is very useful in
the real memory mapped {\it Versat} architecture.
% metrics: 1 vs 4 in v[i] (delta=3072)

The {\it back-end} data structure also defines some
architecture requirements.
These include the endian number format representation
({\tt little\_endian=1} in {\it Versat}),
whether multiplication and division are executed
in hardware or by software libraries
({\tt mulops\_calls=1} or library in {\it Versat}),
whether the {\it back-end} can handle a {\bf DAG}
(directed acyclic graph), or only a tree
({\tt wants\_dag=0} or tree in {\it Versat}), or if
it can handle passing structures to and from
functions: {\tt wants\_callb=0} and {\tt wants\_argb=0}.
When the {\it back-end} does not handle structure
passing directly, the compiler
does not generate {\tt CALLB} or {\tt ARGB}
nodes, and block copies
must be handled by a {\tt blkloop} function.

The final part of the {\it back-end} data structure
defines a set of procedures to handle
specific parts of the code generation.
These include {\tt progbeg} (setup {\it back-end}),
{\tt progend} (finalize {\it back-end}),
{\tt rmap} (define a new register set),
{\tt segment} (change segment),
{\tt target} (assign register for specific instructions),
{\tt clobber} (spill registers before specific operations),
{\tt emit2} (emit code that can not handled by string template),
{\tt blkfetch} (block based fetch code),
{\tt blkstore} (block based store code),
{\tt blkloop} (memory block copy),
{\tt doarg} (register assignment to arguments),
{\tt local} (register assignment to locals),
{\tt function} (generate a function activation record),
{\tt defsymbol} (define a symbol),
{\tt  address} (compute an address),
{\tt defconst} (define a literal constant),
{\tt defaddress} (define an address),
{\tt defstring} (define an string),
{\tt export} (declare an exported symbol),
{\tt import} (declare an external symbol),
{\tt global} (declare a global symbol),
{\tt space} (reserve uninitialized data)
\cite[p.79]{hanson95}.

\section{Register assignment}

In order to implement the {\bf C} language constructs,
the processor must provide an accumulator to handle
return values from functions, a stack pointer to save
arguments, locals and spills, and a frame pointer to
access arguments and locals by a fixed amount.
All of these registers can be set in fixed memory positions,
but the execution degradation is significant.

% R0 cannot be used (picoversat/rtl/testbench/xtop\_tb.c:76) 'wait for versat to reset R0' means that when you write 0 to R0 picoversat halts!!!
% Register description: versat/assembly_src/boot.va
% R0 : address register for reading, writing or running
% R1-R12: program parameters
% R13 : temporary storage
% R14 : command register (from host to guest and vice-versa)
% R15 : data register

The {\it picoVersat} has $16$ registers, but only registers
{\tt R1} through {\tt R12} are available as program
parameters.
The register assignment set {\tt R12} as a stack pointer, and
{\tt R11} as a frame pointer.
The stack pointer is initially set to the highest memory position
{\tt 0x1FFF}, and the stack grows downward to lower memory addresses.
Also, the stack pointer points to the last used position.
% produces small sequences
Hence, the address {\tt 0x1FFF} is used to store the
return address {\tt end} (see section~\ref{boot})
before the {\tt main} is called.

The accumulator is not a fixed register and requires spilling
only when non-void functions are called, in order to hold the
return value.
The first register {\tt R1} ({\sc ACC=0}) is assigned as accumulator.
The {\tt target} routine instructs the compiler to free {\bf R1}
before a {\tt CALL+IUP}: {\tt setreg(p, intreg[ACC])}.
The same routine instruct the compiler to place the result of a
{\tt RET+IUP} in {\tt R1}: {\tt rtarget(p, 0, intreg[ACC])}.

The assignment of structures {\tt ASGN+B} performs a block copy,
and requires two temporary registers.
The {\tt clobber} routine spills registers {\tt R1} and {\tt R2}
before the instruction is emitted: {\tt spill(ACC|(ACC+1), IREG, p)}.

The remaining registers are of free use by the compiler.
However, to make code generation more efficient, about half of the
available $10$ registers (from {\tt R1} to {\tt R10}) can be assigned
to temporary values, and the others to store program variables.
Program variables stored in register speed up significantly the
program execution, specially if they require indexing, such as
function arguments, locals and vector indices.
As {\tt R1} and {\tt R2} are already used as temporaries by some
instructions, registers {\tt R1} through {\tt R5} are defined as
temporaries: {\tt tmask=0x1f}.
Registers {\tt R6} through {\tt R10} are defined as variables
registers: {\tt vmask=0x3e0}.
Registers {\tt R12=SP} and {\tt R11=FP} are permanently assigned.

\section{Code selection}

The grammar for the code selection is defined in the second
area of the {\bf lburg} description file.
Each grammar rule defines a non-terminal target, a tree pattern,
an output string, and a selection cost.
For instance, the tree that adds a register with a constant and
produces a register is
\begin{Verbatim}[baselinestretch=1.2]
reg:    ADDI1(reg,con)    "\trdw %0\n\taddi %1\n\twrw %c\n" 3
\end{Verbatim}

% format: non-terminal tree-pattern output-string cost
% literal cost and variable cost function
The selection cost value represents the latency of the full
instruction sequence.
In {\it picoVersat} all instructions take a single clock cycle,
so the cost is the number of instructions.
For dynamic selection of instructions, the cost value literal
is replaced by a function call. This function evaluates the
node and returns a cost value.
A low cost value, usually {\tt 0} or {\tt 1} represents a
selectable instruction, while a high cost value, usually
{\tt LBURG\_MAX} or {\tt 32767}, is returned when the
instruction sequence should not be selected.
Since the compiler chooses the lowest cost sequence to
generate each {\tt stmt}, the grammar {\tt start} symbol,
high cost instructions are never used.
The output strings have {\tt printf} alike escape sequences.
The terminal values in the tree sequence are represented
by {\tt \%0} for the first argument, {\tt \%1} for the
second argument, {\it etc.}, and {\tt \%c} for the result.
The {\tt \%a} escape is used for the first symbol associated
with a node, {\tt \%b} for the second symbol, {\it etc.}
When an output strings starts with a {\tt \#} symbol, the
output is redirected to the {\tt emit2} routine and more
complex computation can be performed, other than simple
string variable substitutions.

For debug purposes, this {\it back-end} strings start with a
comment that identifies the selected rule in the output
assembly file.
However, since the {\it Versat} assembler also uses the
{\tt \#} symbol for comments, a space must be inserted
to avoid redirection of comments in rules to the
{\tt emit2} routine.

The {\it Versat} {\it back-end} uses the non-terminals:
{\tt stmt} for statements (also the grammar start symbol),
{\tt reg} for register values, {\tt fpN} for function
activation frame arguments and locals, {\tt addrg}
for global variables ({\tt ADDRGP + MEM\_BASE}), {\tt con5}
for small literals ({\tt 0} to {\tt 32}) used in shift
operations,
{\tt con1} for loop unrolling of single ({\tt 1}) shift
operations, {\tt addr} is a register that contains and address,
and {\tt adddrj} is a jump or call address (does not use
{\tt MEM\_BASE} in {\it picoVersat-0.0}).

% CONST: 27-b (32-b ldih) ldih only sets highest nibble: 28-31
The non-terminal {\tt con} represents a literal
representable in $28$ bits,
a signed range from $-134217728$ to $134217727$,
that can be embedded in other
{\it picoVersat} instructions like {\tt addi}.
\begin{Verbatim}[baselinestretch=1.2]
con:    CNSTI1    "%a" range(a, -134217728, 134217727)
reg:    con	" # reg: con\n\tldi %0\n" 1
reg:    CNSTI1    "# long constant\n" 2
reg:    ADDI1(reg,con)    "\trdw %0\n\taddi %1\n\twrw %c\n" 3
reg:    ADDI1(reg,reg)    "\trdw %0\n\tadd %1\n\twrw %c\n" 3
\end{Verbatim}

The tree pattern {\tt con: CNSTI1} has a cost of $1$ if the
constant is in the defined {\tt range} and is selected by
the first rule, otherwise the third rule is used with cost of $2$.
The sum of a register with a constant {\tt ADDI1(reg,con)})
has a cost of $1+3=4$ when the
constant is within the range, and a cost of $2+3=5$ otherwise.
Please note that even a constant within the {\tt range} can use
the sum of two registers ({\tt ADDI1(reg,reg)}),
but the cost is $1+1+3=5$
higher since placing a constant in a register adds $1$ to the cost.

The {\tt stmt: reg} rule states that a statement can be an expression,
an assignment or function call for example, but has a zero ($0$)
cost since the value can be left the register with not additional
instructions.

\section{Code emitting}
The sequence too complex to emit code based only a string template
must be handled by the {\tt emit2} routine.
This routine is selected by starting the rule output string with
the {\tt \#} symbol.
In {\it Versat} some instructions require temporary labels like
{\tt CALL}, {\tt RSH} or {\tt LSH} and must be handled by {\tt emit2}.

All code in this routine is printed by a {\tt print} routine
that uses {\tt \%s} and {\tt \%s} to output variables,
as in a regular {\tt printf}.
However, the examples presented in this section have the
escape values replaced by {\tt \%0} for the first argument,
{\tt \%1} for the second argument, and {\tt \%c} for the result.
The {\tt \%d} is used for generated label numbers.

The {\tt CALL} instruction does not exist in {\it picoVersat}.
Its emulation must store the return address before
jumping to the address of the routine.
Since calls from different places require a different
return address, the {\tt genlabel(1)} function creates
a new label name for each call. Note that the {\tt nop}
is executed twice, as a delay slot during the call and
upon return from the function call.
The resulting code is
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    addi -1
    wrw R12
    wrw RB
    ldi L%d
    wrwb
    ldi 0
    beqi %s
L%d nop
\end{Verbatim}

If the function was called with arguments, their size
is stored in the first symbol ({\tt \%a}).
After returning from the call, all arguments must be removed.
This is achieved by adding their size to the stack pointer:
{\tt SP+=size}.
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    addi %a
    wrw R12
\end{Verbatim}

The {\tt CALL+IUP} (for integers, unsigned and pointer
return values) must define the register that holds the
function return value by calling
\begin{Verbatim}[baselinestretch=1.2]
setreg(p, intreg[ACC]);
\end{Verbatim}

in the {\tt target} routine ({\tt intreg[ACC] = R1}).
Note that {\tt CALL+V} does not return a value and
does not need to assign a target register for the instruction.

In {\it picoVersat} the shift operations only shift
one bit (left or right).
In order to support multiple shifts in a single
instruction a loop must be implemented.
Shift operations are performed by a cycle that decrements
the counter and shifts the destination register by one.
Right shift replaces {\tt shft -1} by {\tt shft 1}.
\begin{Verbatim}[baselinestretch=1.2]
    rdw R%0
    wrw R%c
    rdw R%1
    wrw RB
    beqi L%d1
    nop
L%d rdw R%c
    shft -1
    wrw R%c
    rdw RB
    addi -1
    wrw RB
    bneqi L%d
L%d1 nop
\end{Verbatim}

The code generation requires that a comparison is coded
as a branch when the condition hold {\em true}.
If the condition hold {\em false}, the instruction should
not branch to the given label.
The comparison {\em greater-than-unsigned} ({\tt GTU1})
requires that the result is {\em not-zero} an {\em no-carry},
a label was required to implement the {\em logical-or}
using branches.
Unlike all other comparison instructions,
{\em greater-than-unsigned} had to be specifically coded
\begin{Verbatim}[baselinestretch=1.2]
    rdw R%0
    sub R%1
    beqi L%d
    ldi 1
    and RC
    bneqi L%d
    ldi 0
    beqi %a
L%d nop
\end{Verbatim}

{\it picoVersat} does not have instructions for
multiplication or division, like many low budget processors.
For these processors, the operations are performed by library
functions.
The {\tt mulops\_calls=1} flag in the {\it back-end} configuration
data structure makes the compiler generate regular functions
calls for these operations.
However, the coding of these operations can be optimized,
since {\tt SP=R12} manipulation is simpler because $3$
pushes are performed in sequence, with register saves.
%The {\tt target()} sets arguments to {\tt R1+R2} ($rtarget$)
%and return to {\tt R1} ($setreg$), but it not needed as long
%as library routines are coded in C.
%It might be useful if they are coded in assembler
%(not used in this thesis).
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    addi -1
    wrw RB
    rdw R%1
    wrwb
    rdw R12
    addi -2
    wrw RB
    rdw R%0
    wrwb
    rdw R12
    addi -3
    wrw R12
    wrw RB
    ldi L%d
    wrwb
    ldi 0
    beqi %s
L%d rdw R12
    addi 2
    wrw R12
    rdw R1
    wrw R%c
\end{Verbatim}

The {\tt range} cost routine selects those literals that can handled
inline with some instructions.
For large integer literals two instructions must be emitted,
one for the low bits and another for the high bits.
Since the {\tt ldi} instruction can handle upto $28$ bit constants a
{\tt 0xFFFFFFF} mask is used, while the {\tt ldih} instruction sets
the literal high nibble by shifting right $28$ bits the constant.
\begin{Verbatim}[baselinestretch=1.2]
    ldi 0x%x
    ldih 0x%x
    wrw R%c
\end{Verbatim}

The {\tt LOAD} and conversion ({\tt CVI}, {\tt CVU}, {\tt CVP})
instructions emit no code if the origin and destination
registers are the same. Otherwise a move is emitted
\begin{Verbatim}[baselinestretch=1.2]
    rdw R%0
    wrw R%c
\end{Verbatim}
%   {\tt ADDRG} and address()

The {\tt ASGNB} instruction copies one data structure
into another data structure.
The instruction is implemented by block copy from
{\tt a} to {\tt b}, with offsets {\tt 0} for both, with the
given {\tt p->syms[0]->u.c.v.i} words.
\begin{Verbatim}[baselinestretch=1.2]
blkloop(b, 0, a, 0, p->syms[0]->u.c.v.i, blkregs);
\end{Verbatim}

Since two temporary registers are needed, aside
the source and destination already assigned,
one for the counter and another to hold the
value being copied, a set of two registers is
defined.
\begin{Verbatim}[baselinestretch=1.2]
static int blkregs[] = { ACC+1, ACC+2 };
\end{Verbatim}

This set, composed of {\tt R1} and {\tt R2},
is used in the {\tt ASGNB} instruction
and is used by {\tt clobber} routine to {\tt spill}
the registers prior to the execution of the
{\tt ASGNB} instruction.
\begin{Verbatim}[baselinestretch=1.2]
case ASGN+B: spill(ACC|(ACC+1), IREG, p); break;
\end{Verbatim}

The return instruction ({\tt RET+IUP}, not {\tt RET+V})
must inform the compiler through the {\tt target} routine
that the return value is {\tt R1=ACC}.
\begin{Verbatim}[baselinestretch=1.2]
case RET+I: case RET+U: case RET+P: rtarget(p, 0, intreg[ACC]); break;
\end{Verbatim}

\section{Function handling}
The {\tt function()} routine must handle all the specifics
of defining a function, including its activation frame.
The activation frame is the organization of arguments,
return pointer, saved registers, frame pointer, and
local variables of a routine.
Its memory mapping depends on whether the arguments are
passed in registers or on the stack, {\it etc.}

The {\tt gencode} routine performs a simulation of the
code generation for the routine.
No code is produced, but it is determined the number of
registers necessary for its implementation, the offset
of its arguments and locals (local variables).

Before the code is actually generated by the {\tt emitcode}
routine, all clobbered registers must be saved by issuing
push instructions for each one.
The push of register-{\tt i} is {\tt [--R12] = Ri}, where
{\tt R12=SP}.
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    addi -1
    wrw R12
    wrw RB
    rdw R%d
    wrwb
\end{Verbatim}

When a routine is executing, registers can be spilled
into the stack whenever the instruction requests the
use of a specific register, or when no more registers
are available.
The arguments of a routine are stored above the
return pointer, while the local variables are stored below
the return pointer.
Furthermore, their relative offsets to the return pointer
remain fixed, even when registers are spilled to the stack.
If we can keep track of the return pointer, all arguments
and local are in a fixed position.
Most compilers use a frame pointer {\tt FP=R11} to save
this position, and moderns processors like {\bf mips},
{\bf sparc} or {\bf arm} have a frame pointer register.
If no registers are saved, the first argument is at
{\tt FP+2}, the second at {\tt FP+3}, {\it etc.},
while {\tt FP+1} is the return pointer, and {\tt FP}
is the frame pointer of the old routine.

After spilling all register that the routine will use,
the old frame pointer for the previous routine must
also be saved, and the new frame pointer points to
the current stack pointer; {\tt PUSH fp; MOV fp, sp}
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    addi -1
    wrw R12
    wrw RB
    rdw R11
    wrwb
    rdw R12
    wrw R11
\end{Verbatim}

Before the routine code can be emitted, the space for all
local variables must be reserved.
Since {\tt gencode} already determined the space
required by the routine locals, the stack pointer
is decremented by that amount, leaving a chunk
of stack unused for those locals: {\tt SP-=size}
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    addi -%d
    wrw R12
\end{Verbatim}

After the routine is emitted ({\tt emitcode}),
all locals must be freed.
Since all locals are below the frame pointer,
moving the stack pointer to the frame pointer
effectively ignore all locals below the
stack frame.
Then the old frame pointer must be restored:
{\tt MOV sp, fp; POP fp}
\begin{Verbatim}[baselinestretch=1.2]
    rdw R11
    wrw R12
    wrw RB
    rdwb
    rdwb
    wrw R11
    rdw R12
    addi 1
    wrw R12
\end{Verbatim}

At the end of the code generation for the routine,
all saved registers must now be restored in reverse
order.
The pop of register-{\tt i} is {\tt Ri = [R12++]}.
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    wrw RB
    rdwb
    rdwb
    wrw R%d
    rdw R12
    addi 1
    wrw R12
\end{Verbatim}

Now the stack only contains the return pointer
and the routine arguments.
Since in {\bf C} the caller must push and pop
the arguments, in order to support variadic
function arguments like {\tt printf}, the
routine is only required to remove the
return pointer and jump to its location.
\begin{Verbatim}[baselinestretch=1.2]
    rdw R12
    wrw RB
    rdwb
    rdwb
    wrw RB
    rdw R12
    addi 1
    wrw R12
    ldi 0
    beq RB
    nop
\end{Verbatim}

The {\it picoVersat} assembler is a very simple tool.
If the user names a function or a global variable
after a {\it picoVersat} instruction, the assembler
silently ignores and emits the stored value.
Since some names are pretty common, like {\tt and},
{\tt add} or {\tt sub}, the code checks whether
the user defines any of those names, and issues an
error.
\begin{Verbatim}[baselinestretch=1.2]
static char *invalid[] = { "and", "bneq", "IMM_W", "rdwb", "ldi",
"DELAY_SLOTS", "MEM_BASE", "SEL_ADDR_W", "beqi", "R14", "R15", "xor",
"sub", "R10", "R11", "wrw", "add", "EXT_BASE", "RB", "ldih", "addi",
"R4", "R5", "R6", "R7", "R0", "R1", "R2", "R3", "RC", "R8", "REGF_BASE",
"R9", "CPRT_BASE", "DATA_W", "R12", "OPCODESZ", "R13", "rdw",
"beq", "ADDR_W", "shft", "wrwb", "INSTR_W", "bneqi", "REGF_ADDR_W",
"nop", 0 };
\end{Verbatim}

This behavior was detected many hours after an
{\tt add} routine was defined and the output made
no sense.
\begin{Verbatim}[baselinestretch=1.2]
    for (i = 0; invalid[i]; i++)
        if (!strcmp(invalid[i], f->x.name))
            error("'%S' can not be used\n", f->x.name);
\end{Verbatim}

In {\tt defconst} the literal is emitted unsigned since
{\tt .memset} does properly sign extend negative numbers.
For instance, $-12$ is coded as {\tt 0x0FFFFFF4} and not
as {\tt 0xFFFFFFF4}.

\section{Code optimization}

A code selection tool like {\bf lburg} allows the insertion of
alternative tree selection patterns that can be used in specific
trees with an inferior cost than the generic rules required
for all instructions.

As referred above, the add instruction ({\tt ADD+IUP}) can be
performed with a register {\tt add} or with an immediate
value {\tt addi}.
Although the cost is {\tt 3} in both cases, the use of an immediate
value saves a register and the respective store instruction that
was previously required.
Note that the operation between two registers is required to perform
sums, while the sum with a constant is an optimization when one
of the values is not already stored in a register.
The compiler can always choose to save the immediate in a register,
and then perform the sum between registers.
The costs should be defined in such a way that it is more costly
to load the immediate to a register.
The compiler also detects that the instruction is commutative,
so there is no need for a {\tt (reg, con)} and {\tt (con,reg)} rules.
\begin{Verbatim}[baselinestretch=1.2]
reg:    ADDI1(reg,con)    "\trdw %0\n\taddi %1\n\twrw %c\n" 3
reg:    ADDI1(reg,reg)    "\trdw %0\n\tadd %1\n\twrw %c\n" 3
\end{Verbatim}

The instructions {\tt BAND+IU}, {\tt BXOR+IU}, {\tt ASGN+IUP},
{\tt ARG+IUP} can not handle immediates.
However, by replacing a {\tt rdw} by a {\tt ldi} instruction
a register is also saved.
\begin{Verbatim}[baselinestretch=1.2]
reg:    BANDI1(reg,con)    "\tldi %1\n\tand %0\n\twrw %c\n" 3
reg:    BANDI1(reg,reg)    "\trdw %0\n\tand %1\n\twrw %c\n" 3
\end{Verbatim}

The shift instructions are very costly since they
must be implement through loop.
In order to unroll the loop, optimizations can be
defined for each shift value, as long as it is a literal.
When both values reside in registers, no optimizations
are possible.
For the single shift case, a constant of value {\tt 1} (in the
{\tt range} from {\tt 1} to {\tt 1}) is defined ({\tt con1}).
The shift operations that use {\tt con1} must only perform
a single shift.
The same concept can be extended for {\tt 2}, {\tt 3}, {\it etc.}
\begin{Verbatim}[baselinestretch=1.2]
con1:   CNSTI1     "%a"    range(a, 1, 1)
reg:    LSHI1(reg,con1)    "\trdw %0\n\tshft -1\n\twrw %c\n" 3
reg:    RSHI1(reg,con1)    "\trdw %0\n\tshft 1\n\twrw %c\n" 3
\end{Verbatim}

The {\it Versat} processor is controlled by {\it picoVersat} by
writing values to specific memory positions.
As such, vector addressing instructions are common and should
be optimized.
To optimize such instructions, the compiler was run in debug
mode, where it emitted the trees it was selecting.
Two such cases were identified, where global vectors where
indexed by literal and assigned literals:
{\tt vec[6] = 3; ptr[6] = 3}
Local vectors require frame pointer indexing and are implicitly
slower.
The two tree patterns selected correspond to global pointers
and vectors: {\tt int vec[10], *ptr;}
\begin{Verbatim}[baselinestretch=1.2]
stmt:    ASGNI1(ADDP1(INDIRP1(addrg),con),con)
            "\twrw RB\n\trdwb\n\trdwb\n\taddi %1\n\twrw RB\n\tldi %2\n\twrwb\n" 7
stmt:    ASGNI1(ADDP1(addrg,con),con)
            "\taddi %1\n\twrw RB\n\tldi %2\n\twrwb\n" 4
\end{Verbatim}
% pico.md

%\section{Assembler support}
%ldi PC
%(includes ...)
%(python3 ...)

\section{{ASM} support}

The use of an {\tt asm} call is important to
have a low level control over the {\it Versat}.
Since the compiler did not support {\tt asm} calls
(see section~\ref{lcc}) a generic support was
added.
Any {\it back-end} can activate the {\tt doasm} flag
in its {\tt progbeg} routine and a {\tt CALLASM}
instruction is generated for selection.

The variable is declared in {\bf c.h}:
\begin{Verbatim}[baselinestretch=1.2]
extern int doasm;
\end{Verbatim}

The variable is defined in {\bf main.c}:
\begin{Verbatim}[baselinestretch=1.2]
int doasm; /* accept asm("assembly code") */
\end{Verbatim}

If the flag is set and the function is named
{\tt asm}, a string literal ({\tt SCON}) is read.
Otherwise an error is issued by {\tt expect}.
Then a {\tt CALL} node is built.
The change were added after line {\tt 297} in the file
{\tt expr.c}:
\begin{Verbatim}[baselinestretch=1.2]
  if (doasm && p->u.sym && !strcmp(p->u.sym->name, "asm")) {
    Type ty = func(voidtype, NULL, 1);
    int tk;
    t = gettok();
    tk = t;
    expect(SCON);
    if (tsym && tk == SCON) {
      Symbol s = malloc(sizeof *tsym);
      *s = *tsym;
      s->name = strdup("asm");
      p->u.sym = s;
      p->u.sym->x.name = strdup(tsym->u.f.pt.file);
      expect(')');
      return tree(mkop(CALL, ty), ty, p, NULL);
    }
  }
\end{Verbatim}

The selection accepts a pointer to a global
variable that represents the string generated.
\begin{Verbatim}[baselinestretch=1.2]
addrj:   ADDRGP1    "%a"
stmt:    CALLASM(addrj)    " # ASM\n%0\n"    1
\end{Verbatim}

Note that only literals at compile time can be used
because the values must be outputted to the assembly file.
Since register assignment is performed by the compiler,
there is no way of knowing which register will be
assigned to a given variable.
Exceptions are global variables, always referred by name,
and locals that have a fixed offset to the frame pointer.
However, in the later case the user must write simple
routines, with no register spilling, so that the offsets
are known.

\section{Program bootstrapping}\label{boot}

The program bootstrapping consists on setting up the
processor before calling the {\tt main()} routine, the
actual calling of the {\tt main()} routine, and the
cleaning up after calling the {\tt main()} routine.

The setup of the main routine sets the stack pointer to
the top of the stack and sets the frame pointer to zero.
The top of the stack is stored in {\sc R12} and must be
determined from {\sc ADDR\_W} and {\sc MEM\_BASE}:
{\tt R12=MEM\_BASE+2**(ADDR\_W-1)-1}
\begin{Verbatim}[baselinestretch=1.2]
      ldi 1
      wrw R12
      ldi ADDR_W
      addi -1
      wrw RB
_next rdw RB
      beqi _top
      rdw R12
      shft -1
      wrw R12
      rdw RB
      addi -1
      wrw RB
      ldi 0
      beqi _next
_top  rdw R12
      addi -1
      addi MEM_BASE
      wrw R12
\end{Verbatim}

No arguments ({\tt argc, argv, envp}) are passed, so the
{\tt main} routine is directly invoked.
The return address {\tt end} is saved at the top of the
stack, the frame pointer {\sc R11} is set to zero, the
{\tt main()} routine is called and the return address is
defined:
\begin{Verbatim}[baselinestretch=1.2]
      wrw RB
      ldi end
      wrwb
      ldi 0
      wrw R11 #FP=0
      beqi main
end   nop
\end{Verbatim}
The {\tt nop} instruction is executed twice, as a delay
slot for {\tt beqi} and upon return from the routine.

On debug mode, upon return, before the run is terminated,
a debug feature prints the {\tt main} return value as a
single hexadecimal nibble; possible values are from {\tt 0}
to {\tt 9} and then the following {\sc ASCII} codes {\tt ':'},
{\tt ';'}, {\tt '<'}, {\tt '='}, {\tt '>'}, {\tt '?'}.
Therefore, simple test programs just return operation values
from {\tt main}.
\begin{Verbatim}[baselinestretch=1.2]
end  ldi 0xF
     and R1
     addi 0x30
     wrw CPRT_BASE
     ldi 0xa
     wrw CPRT_BASE
\end{Verbatim}

Finally, to end the program, a trap must be generated.
The trap address is {\tt MEM\_BASE+2**ADDR\_W-1} and is
determined in the same way as the top of the stack:
\begin{Verbatim}[baselinestretch=1.2]
        ldi 1
        wrw R12
        ldi ADDR_W
        wrw RB
_again  rdw RB
        beqi _trap
        rdw R12
        shft -1
        wrw R12
        rdw RB
        addi -1
        wrw RB
        ldi 0
        beqi _again
_trap   rdw R12
        addi -1
        addi MEM_BASE
        wrw RB
        wrwb
\end{Verbatim}

\section{Runtime support}

Since the assembler does not support multiple files,
and there is no support for explicit file liking,
the runtime support must be added by include files.
These included files have the usual declarations
and defines, but also routines fully coded.
There is no problem of multiple definitions since
there is no linking.

The {\tt include/} directory includes some basic
routines to support program development and debugging.
These include basic printing ({\tt putchar.h}, {\tt puts.h},
{\tt printi.h}, {\tt printf.h}),
conversion ({\tt atoi.h}, {\tt itoa.h}, {\tt strlen.h}),
memory ({\tt alloca.h}, {\tt malloc.h}) and {\it versat}
support ({\tt versat.h}, {\tt dma.h}, {\tt assign.h},
{\tt xdict.h}, {\tt ends.h}).

The {\tt putchar} routine uses the {\it picoVersat} debug capability to
print a single {\sc ASCII} character to the simulation terminal.
It allows the debug and testing of the program examples used in this work.
\begin{Verbatim}[baselinestretch=1.2]
void putchar(int ch) {
    asm("\trdw R11\n\taddi 2\n\twrw RB\n\trdwb\n\trdwb\n\twrw CPRT_BASE\n");
}
\end{Verbatim}

The function is called using the usual {\bf C} language convention, and then
the function argument is fetched from the {\it stack-frame}.
The offset ($2$) accounts for the saved {\it frame-pointer} and the function
return address, both pushed to the stack after the argument was saved on the
stack.

The {\tt mul.h}, {\tt div.h} and {\tt mod.h} files
include the routines invoked by the compiler
for the {\bf C} operators for
multiplication ({\bf *} $\rightarrow$ {\tt \_mul}),
division ({\bf /} $\rightarrow$ {\tt \_div}), and
remainder ({\bf \%} $\rightarrow$ {\tt \_mod}).
\begin{Verbatim}[baselinestretch=1.0]
int _mul(int a, int b) {
    int mul;
    for (mul = 0; b; b >>= 1, a <<= 1)
        if (b & 1)
            mul += a;
    return mul;
}

int _div(int a, int b) {
    int x = 0;
    while (a > b) a -= b, x++;
    return x;
}

int _mod(int a, int b) {
    while (a > b) a -= b;
    return a;
}
\end{Verbatim}

The implementations are very simple and inefficient but
prove the concept and fit the limited memory available.

Memory allocation on the heap uses the memory between static data (functions
and global variables) and the top of the stack.
The top of the stack is maintained by register {\tt R12}.
To signal the end of the static data, the compiler inserts an integer
variable, called {\tt \_end}, and initialized to zero ($0$).
The value of this variable is then used as the head of an allocation block
list, entirely written in {\bf C} ({\tt malloc.h}).
The allocator checks whether the required memory would overlap with the stack,
but since stack allocations (function calls, arguments and local variables)
do not perform the inverse check, stack overruns are possible.

Implementation of memory allocation on the stack (see the {\tt alloca}
{\bf C} library routine) requires the effective movement of the stack pointer.
Special care must taken during expression evaluation, since temporaries may
clobber the stack.
The implementation provided is very simple and decreases the stack by the
given amount {\tt sp -= size } (in 32-bit words).
The {\tt sp()} routine then returns the new stack top value, which is the
allocated block lowest address, since the stack runs from high addresses
to low addresses.


\section{Application integration}\label{app:integ}

The compiler {\bf lcc} is composed of several applications
that, when used in sequence, produce an executable from
a given source file.
The {\tt lcc/etc} directory contains the code for the
generation of the top level {\tt lcc} application that
controls the preprocessor ({\bf cpp}), the compiler
({\bf rcc}),  the assembler ({\bf va}) and the loader.
The {\tt lcc/etc/versat.c} file controls arguments and
invocation of these sub-applications.
The preprocessor is invoked with \verb|-Dversat| so that
programs can use \verb|$ifdef| directives to select
specific code.
The compiler must be invoked with \verb|-target=versat|
to select the {\it back-end}.
The assembler is invoked with an optional third argument
that points to \verb|xdict.json| file.
The {\it verilog} compiler ({\bf iverilog}) works as a loader
allows the generation of a final executable from the
assembly file generated.

The {\it versat} assembler requires a {\tt xdict.json} file,
for defining constants, in the current directory. For a
smooth integration, this file should be passed an optional
third argument, enabling it to reside in a different directory.

In order to control the assembly file read by {\bf iverilog},
the {\it picoVersat} {\tt picoversat/rtl/src/xram.v} file
(line $65$) was modified to support the constant {\tt INPUT}
instead of the literal \verb|"program.hex"|.
\begin{Verbatim}[baselinestretch=1.2]
      $readmemh(`INPUT,mem,0,2**(`ADDR_W-1)-1);
\end{Verbatim}

The {\bf iverilog} tool must now be invoked with
\verb|-Dinput=\"source.hex\"| where \verb|source.hex|
is the input file.
% comment lines 46-49 in rtl/testbench/xtop_tb.v to remove xtop.vcd

\section{Data engine incorporation}

The {\tt versat} {\sc CGRA} configuration is memory mapped,
thus each functional unit can be configured by writing to
specific memory addresses.
The writing can be performed by ordinary {\bf C} language
assignment instruction of the form {\tt *addr = value;}
where the {\tt addr} variable was previously set to the
specific memory address.

The data engine controls {\tt 19} functional units:
{\tt 8} memories (from {\tt 0} to {\tt 3} and {\tt A}
to {\tt B}), {\tt 6} {\sc ALU}s ({\tt 2} full {\sc ALU}s
and {\tt 4} {\em lite}), {\tt 4} multipliers (from {\tt 0}
to {\tt 3}) and a {\sc BS}.
Each functional unit is configured by a register, from
address {\tt 6176} to {\tt 6194} when {\tt N\_W=5}.
\begin{Verbatim}[baselinestretch=1.2]
typedef struct versatDE {
    int mem0A, mem0B, mem1A, mem1B, mem2A, mem2B, mem3A, mem3B;
    int alu0, alu1, alulite0, alulite1, alulite2, alulite3;
    int mult0, mult1, mult2, mult3, bs0;
} VersatDE;
\end{Verbatim}

Depending on the type of functional unit, a number of
parameters can be defined by writing to a set of
configuration register.
Each memory includes {\tt 9} parameters ({\tt iter},
{\tt per}, {\tt duty}, {\tt sela}, {\tt start}, {\tt shift},
{\tt incr}, {\tt delay}, and {\tt rvrs}).
Each {\sc ALU} includes {\tt 3} parameters ({\tt sela},
{\tt selb}, and {\tt fns}).
Each multiplier includes {\tt 4} parameters ({\tt sela},
{\tt selb}, {\tt lonhi}, and {\tt div2}).
The {\sc BS} includes {\tt 4} parameters ({\tt sela},
{\tt selb}, {\tt lna}, and {\tt lnr}).
These $8 \times 9 + 6 \times 3 + 4 \times 4 + 4 = 110$
configuration registers, and a clear register, are mapped
from address {\tt 5119} to {\tt 5229}.
\begin{Verbatim}[baselinestretch=1.2]
typedef struct versat {
    struct mem { int iter, per, duty, sela, start, shift, incr, delay, rvrs; }
        mem0A, mem0B, mem1A, mem1B, mem2A, mem2B, mem3A, mem3B;
    struct alu { int sela, selb, fns; }
        alu0, alu1, alulite0, alulite1, alulite2, alulite3;
    struct mult { int sela, selb, lonhi, div2; }
        mult0, mult1, mult2, mult3;
    struct bs { sela, selb, lna, lnr } bs;
} Versat;
\end{Verbatim}

The {\tt xdict.h} file defines the same {\tt xdict.json}
file constants for {\bf C} programs.
The {\tt ends.h} file, made from {\tt mem\_ends.h} file,
defines the constant values as integer literals and not
as expressions, so they can be used in {\tt asm()}
directives, since their values must be known at compile time.

The {\tt versat()} routine can be used to efficiently insert
a compile time constant value in {\it Versat} configuration
addresses, using only $2$ instructions.
Use the {\tt set()} routine or the {\tt setvar()} routine
(in {\bf C}, but slower) to insert runtime determined values.
However, the fastest approach is to make a simple {\bf C}
indirect pointer assignment, where the pointer is initialized
to the destination address, $10$ instructions for the
assignment (local or global scalar variable), and {\tt 9}
to assign the address to the pointer.
\begin{Verbatim}[baselinestretch=1.2]
/* ../obj/cpp mem_ends.c | ../obj/rcc -target=versat > mem_ends.va */
#include "xdict.h"
#include "ends.h"
#define str(s) #s /* stringify */
#define ALU_CLZ 13 /* program.h */
#define versat(alu,base,offset) \
    asm("\tldi " str(alu) "\n\twrc " str(base) "," str(offset) "\n")
void set(int value, int *addr) {
    asm("\trdw R11\n\taddi 2\n\twrw RB\n\trdwb\n\trdwb\n\twrw R1\n"
"\trdw R11\n\taddi 3\n\twrw RB\n\trdwb\n\trdwb\n\twrw RB\n\trdw R1\n\twrwb\n");
}
void setvar(int value, int *addr) { *addr = value; }
\end{Verbatim}

\begin{Verbatim}[baselinestretch=1.2]
int main() {
    int pos = 0x123456, *addr = (int*)pos; /* see limitations */
    versat(ALU_CLZ,ALU0_CONFIG_ADDR,ALU_CONF_FNS_OFFSET);
    set(12, (int*)pos);
    setvar(13, (int*)pos);
    *addr++ = 14;
    *addr++ = 15;
    *addr = 16;
    return 1;
}
\end{Verbatim}

\section{picoVersat versions}

During the development of this work there were 3 major {\it picoVersat}
versions, designated in this document as:
\begin{description}
\item[picoVersat-0:] as of March 4 ({\tt 4a9c764}), is the start version.
	It requires a read-only {\tt bootrom} that then transfers control
	to the user program. Functions and data are stored separately,
	requiring an {\tt addi MEM\_BASE} instruction to access data.
	This, however, poses a problem in {\bf C} since function pointers
	are data, but the offset should not be added.
	The function segment size was only 256 words, restricting tests to
	very small examples. This is specially true because there is no
	{\tt call} or stack support instructions, making those simple
	operations very long as detailed in this chapter.
\item[picoVersat-1:] as of July 27 ({\tt ee36325}), is the first fully
	workable version.  Both, {\tt bootrom} and data offset, were removed.
	Memory is now 8192 words long, for both functions and data, making
	comprehensive testing of the compiler possible.
	This version exhibited problems with {\it flags}, but alternative
	code was inserted to overcome this limitation.
\item[picoVersat-2:] as of September 13 ({\tt dda9dfa}), flags are now
	working and the {\tt wrc} macro instruction was removed.
	All 16K-word of program and data memory are now acessible.
\end{description}

%\section{Summary}

%[] interface4.pdf OK @techreport\{lcc4,
%[] interface.pdf (basics: OK) @article\{Fraser:1991,
%[] iburg.pdf ?  @article\{Fraser:gen92,
