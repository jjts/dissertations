%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                      %
%     File: Thesis_Versat.tex                                          %
%     Tex Master: Thesis.tex                                           %
%                                                                      %
%     Author: Andre C. Marta                                           %
%     Last modified :  2 Jul 2015                                      %
%                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Current Simulation and Implementation Status}

Since this thesis consists on a hardware implementation of an algorithm, it
requires a set of tools to properly test its functionalities. The first step is
by simulation. As a prototype of the sample rate converter was already developed
and simulated, some preliminary results related to this step are already shown
in this chapter. The second step is the implementation of the core in a FPGA,
including support for its use in a System-on-a-Chip.

\section{Simulation}
\label{section:sim}

To simulate the hardware, Cadence's \textit{NCsim} simulator is used. To test
the algorithm, two scripts are devloped: one that generates the input signal and
one that evaluates the converter's output signal.

\subsection{Filter Coefficients And Input Signal Generation}
\label{section:input_script}

To generate the output signal, the sample rate converter core needs the
fractional delay filter coefficients and the input signal which are generated by
a script described in this section.

To generate the coefficients, the script receives three values:
$filter\_nzeros$, $filter\_nfrac$, and $H\_bits$, which give the number of
zeroes of the sinc function, the number of address bits to address the filter's
memory, and the number of bits to quantify the value of the coefficients,
respectively. With these values, the script generates an ideal sinc function and
truncates it using window function. Since the result is a symmetric function,
only half the window values are taken to fill the coefficient memory. A snippet
of the \textit{Octave} code of this script is shown in
Listing~\ref{list:getCoeffROM}.

\begin{lstlisting}[language=Octave, caption={Coefficients generation script}, label={list:getCoeffROM}, frame=single, breaklines=true]
  function filter_tab = getCoeffROM(filter_nzeros, filter_nfrac, H_bits)
     filter_t_res = 1/2**filter_nfrac;
     filter_t = 0: filter_t_res : filter_nzeros/2 -  filter_t_res; %normalized positive time axis
     window = kaiser(2*length(filter_t)-1, 12.4)';
     window = window(length(filter_t): 2*length(filter_t)-1); %take half window
     filter_tab = (2^(H_bits-1)-1)*sinc(filter_t) .* window; %build one sided impulse response filter table
     filter_tab = do_2s_comp(round(filter_tab), H_bits);
     return
     endfunction
\end{lstlisting}

To generate the input samples, the script generates a sinusoidal signal and
samples it at the input sample rate. To do this, the script needs the sinusoid's
frequency $Ftest$, the duration of the signal in input samples $TD$, the number
of bits to quantize the samples $H\_bits$, and the input signal's sample rate
$Fin$. With these values a vector with all input samples is generated. Regarding
the amplitude of the input signal, it is set slightly below unity to prevent
overflows during processing. An example script is outlined in
Listing~\ref{list:genInput}.

\begin{lstlisting}[language=Octave, caption={Input generation script}, label={list:genInput}, frame=single, breaklines=true]
  function x = genInput(Ftest, TD, H_bits, Fin)
      %compute test duration in seconds
      td = TD/Fin;
      %compute input wave x
      t_in = 0: 1/Fin : td-1/Fin; %input time axis
      %create test wave with -1dB input gain
      x = sin( 2*pi*Ftest*t_in + pi/4) * 10^(-1/20);
  
      %quantize x to 1Q23
      x = round( x*2^(H_bits-1) );
      %do 2s complement
      x = do_2s_comp(x, H_bits);
      return
  endfunction
\end{lstlisting}

To apply these signals in hardware simulation, they are written to a file using
hexadecimal notation. The simulation testbench loads this file to read the input
signal from it. The testbench also loads configuration values such as the number
of channels or output signal sample rate.

\subsection{Output Validation}
\label{subsection:output_script}

To test the output signal, a script which computes its spectrum and the total
harmonic distortion plus noise ratio is run.  This script receives as inputs the
array of output samples $y$, obtained by reading a file produced by the
simulation, the original sinusoid's frequency $Ftest$, and the output sampling
rate $Fout$.

To prevent spectrum artifacts, an integer number of periods is extracted from
$y$ and used by the script. To obtain the signal's spectrum, a fast Fourier
transform is used.  Then, the total harmonic distortion plus noise ratio is
computed by summing the power value of every bin which is not deemed to belong to
the original sinusoid signal. A small tolerance around the test frequency is
allowed to compensate for the difficult to avoid scattering when computing
spectra. An example script is presented in Listing~\ref{list:getTHDN}.

\begin{lstlisting}[language=Octave, caption={Output analysis script}, label={list:getTHDN}, frame=single, breaklines=true]
  function thdn = getTHDN(y, Ftest, Fout)
  
      Nypts = length(y);
      f_axis = 0: Fout/Nypts :Fout/2-Fout/Nypts;

      % compute bandwidth surrounding the fundamental
      sig_bin_width = 8; 
  
      Y=abs(fft(y))/Nypts;
      tone_idx = round(Ftest/Fout*Nypts)+1;
      signalBins = tone_idx-floor(sig_bin_width/2):tone_idx+floor(sig_bin_width/2);
      signalBins = signalBins(signalBins>0); %remove bins lower than 0
      signalBins = signalBins(signalBins<=Nypts/2); %remove bins over FFTpoints/2
      s = norm(Y(tone_idx)); 
      noiseBins = 1: Nypts/2;
      noiseBins(signalBins) = []; %excludes signal bins
      noiseBins(1: floor(sig_bin_width/2)) = []; %excludes DC 
      n = norm(Y(noiseBins));
      thdn = 20 * log10(n/s)
      return
  endfunction
\end{lstlisting}

\subsection{Preliminary Results}
\label{subsection:prel_res}

A prototype of the design proposed in Chapter~\ref{chapter:circ_design} was
implemented during an internship at IObundle, generating preliminary
results. This prototype consists in a sample rate converter with no dynamic ratio
estimator, that assumes that the sample clocks are ideal and have constant
frequency. To obtain the ratio between the sample rates, the input and output
sample clock periods are measured with the system clock and divided using a
hardware divider. The division remainder is accumulated and injected in the
quotient when its value equals the value quotient's least significant bit. This
is done with the purpose of avoiding the propagation of quantization errors.

The system was simulated using the scripts and techniques explained in this
chapter, generating the preliminary results shown in
Table~\ref{tab:prel_results}. While for most cases of upsampling and some cases
of downsampling the -130 dB THD+N specification is already fulfilled, there are
cases where the THD+N is too high, which means the core needs to be
debugged and improved. These results tend to occur when the ratio between input
and output sample rates is not an integer or the inverse of an integer. For the
usual frequencies used in audio applications, this means that this prototype is
unable to convert multiples of $\SI{8}{\kilo\hertz}$ to/from multiples of
$\SI{11.025}{\kilo\hertz}$, which is of course unacceptable.

\begin{table}[!htbp]
  \centering
  \caption{Preliminary results obtained.}
  \label{tab:prel_results}
  \begin{tabular}{|c|c|}
    \hline 
	{\bf Convertion Ratio} & {\bf THD+N}\\ \hline
        \SI{44.1}{\kilo\hertz}:\SI{48}{\kilo\hertz} & \SI{-131.94}{\dB} \\ \hline
\SI{48}{\kilo\hertz}:\SI{44.1}{\kilo\hertz} & \SI{-53.45}{\dB} \\ \hline
\SI{48}{\kilo\hertz}:\SI{96}{\kilo\hertz} & \SI{-140.44}{\dB} \\ \hline
\SI{44.1}{\kilo\hertz}:\SI{192}{\kilo\hertz} & \SI{-131.82}{\dB} \\ \hline
\SI{96}{\kilo\hertz}:\SI{48}{\kilo\hertz} & \SI{-143.71}{\dB} \\ \hline
\SI{192}{\kilo\hertz}:\SI{32}{\kilo\hertz} & \SI{-46.21}{\dB} \\ \hline
  \end{tabular}
\end{table}

\section{Implementation In FPGA}
\label{section:impl}

After all simulation results fulfill the required specifications, the sample
rate converter will be implemented in FPGA.

For the testing an actual system testbench needs to be created to apply real
signals to its input interfaces and collect responses from its output
interfaces. This testbench is in fact another core called the tester core.

Furthermore, since one of the objective is to make the core commercially viable,
the input/output interfaces should be standard, so that it can easily be
connected to third party devices.  For this purpose the core will feature
Advanced eXtensible Interface (AXI) and Inter-IC Sound ($I^2S$) converters
connected to it, and should be tested in a System-on-Chip (SoC).

\subsection{Interfaces}
\label{section:interf}

The list of interface signals can be seen in Table~\ref{tab:top_iface}. Since
this core works in 3 different clock domains, there is at least one different
interface for each domain. For control operations, an AXI-Lite interface is
suitable, which will be running in the system's clock domain,

For the input and output audio samples, there are data streaming interfaces
containing signals from which the input and output sample rates can be measured:
native interface. The core will use simple parallel bus interfaces for this
purpose and, optionally, for greater interoperability input and output $I^2S$
interfaces will be supported. The splitting of the signals and interface
attribution is presented in Table~\ref{tab:ifaces}.

As a simpler alternative to the $I^2S$ interface, a native parallel interface
is also developed and used. This interface uses First In, First Out (FIFO)
structures to send data frames, converting bit streams into a native bus
containing the data samples.

\begin{table}[!htbp]
  \centering
  \caption{Attribution of interfaces to asynchronous sample rate converter signals.}
  \label{tab:ifaces}
  \begin{tabular}{|c|c|c|}
    \hline 
	{\bf Interface} & {\bf Name} & {\bf Direction} \\ \hline
        \hline
	 \multirow{2}{*}{General} & clk & Input\\ \cline{2-3}
	 & rst & Input\\ \cline{2-3}
        \hline \hline
        \multirow{3}{*}{AXI-Lite} & Nc [7:0] & Input\\ \cline{2-3}
        & ro [nb+7:0] & Output\\ \cline{2-3}
        & sync & Output\\ \cline{2-3}
        \hline \hline
        \multirow{4}{*}{I2S (Input)} & x [nb-1:0] & Input\\ \cline{2-3}
        & x\_wclk & Input\\ \cline{2-3}
        & x\_mclk & Input\\ \cline{2-3}
        & x\_wr & Input\\ \cline{2-3}
        \hline \hline
        \multirow{3}{*}{I2S (Output)} & y [nb-1:0] & Output\\ \cline{2-3}
        & y\_wclk & Input\\ \cline{2-3}
        & y\_valid & Output\\ \cline{2-3}
        \hline
  \end{tabular}
\end{table}

\subsection{Implementation And Testing In A System-on-Chip}
\label{section:SoC}

To test the versatility of the core, as well as to create a test environment in
the FPGA, the sample rate converter will be implemented in a SoC which is
currently being developed in another student's thesis, and uses a
picoRV32~\cite{picorv32} RISC-V processor.

The SoC will include the core as a peripheral, stimulate its inputs and observe
its outputs. The SoC will have an AXI-Lite master interface to control the
core. Additionally, it will have two $I^2S$ interfaces, one to send the input
audio samples, and the other to receive the output audio samples.

To test the core in the SoC, a Personal Computer (PC) will be used. A simple
program reads the samples from a .wav file, sends them to the FPGA board through
an Ethernet interface. Using the same communication infrastructure, the PC
will receive back the core output data from the board and run the analysis
scripts on them.

The firmware in the SoC is also simple. It receives the data from the
communication interface and forwards it to  the core through its data output interface.
To receive the core's output, it uses its input data interface, eventually buffering it.
When all samples have been processed and received, the SoC will send them to the
computer through the communication interface.
